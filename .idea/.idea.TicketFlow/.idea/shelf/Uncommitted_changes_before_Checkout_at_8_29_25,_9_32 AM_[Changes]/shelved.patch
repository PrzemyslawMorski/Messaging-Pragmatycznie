Index: src/Shared/TicketFlow.Shared/Messaging/RabbitMQ/RabbitMqMessagePublisher.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using RabbitMQ.Client;\nusing TicketFlow.CourseUtils;\nusing TicketFlow.Shared.Messaging.Partitioning;\nusing TicketFlow.Shared.Messaging.Resiliency;\nusing TicketFlow.Shared.Serialization;\n\nnamespace TicketFlow.Shared.Messaging.RabbitMQ;\n\ninternal sealed class RabbitMqMessagePublisher(ChannelFactory channelFactory, IMessagePublisherConventionProvider conventionProvider, \n    ISerializer serializer, MessagePropertiesAccessor propertiesAccessor, ReliablePublishing reliablePublishing) : IMessagePublisher\n{\n    public async Task PublishAsync<TMessage>(TMessage message, string? destination = default, string? routingKey = default, string? messageId = default,\n        IDictionary<string, object>? headers = default, CancellationToken cancellationToken = default) where TMessage : class, IMessage\n    {\n        var channelOptions = new CreateChannelOptions(\n            publisherConfirmationsEnabled: reliablePublishing.UsePublisherConfirms, \n            publisherConfirmationTrackingEnabled: reliablePublishing.UsePublisherConfirms);\n        var channel = await channelFactory.CreateForProducerAsync(channelOptions);\n        var payload = serializer.SerializeBinary(message);\n        var properties = CreateMessageProperties<TMessage>(messageId, headers);\n        SetPartitionKey(properties, message);\n        \n        var (conventionDestination, conventionRoutingKey) = conventionProvider.Get<TMessage>();\n        \n        ConfigureReliablePublishing<TMessage>(channel, messageId);\n        \n        await channel.BasicPublishAsync(\n            exchange: destination ?? conventionDestination,\n            routingKey: routingKey ?? conventionRoutingKey,\n            basicProperties: properties,\n            body: payload,\n            mandatory: reliablePublishing.ShouldPublishAsMandatory<TMessage>(),\n            cancellationToken: cancellationToken);\n        \n        \n    }\n\n    private BasicProperties CreateMessageProperties<TMessage>(string?  messageId = default, IDictionary<string, object>? headers = default)\n        where TMessage : class,IMessage\n    {\n        var messageProperties = propertiesAccessor.Get();\n        var basicProperties = new BasicProperties\n        {\n            MessageId = messageId ?? Guid.NewGuid().ToString(),\n            Type = MessageTypeName.CreateFor<TMessage>(),\n            DeliveryMode = DeliveryModes.Persistent,\n            Headers = new Dictionary<string, object>()\n        };\n\n        var headersToAdd = headers \n                           ?? messageProperties?.Headers \n                           ?? Enumerable.Empty<KeyValuePair<string, object>>();\n\n        foreach (var header in headersToAdd)\n        {\n            basicProperties.Headers.Add(header.Key, header.Value.ToString());\n        }\n        \n        return basicProperties;\n    }\n\n    private void ConfigureReliablePublishing<TMessage>(IChannel channel, string? messageId)\n    {\n        if (reliablePublishing.UsePublisherConfirms)\n        {\n            channel.BasicNacksAsync += async (s, args) =>\n            {\n                Console.WriteLine(\n                    $\"Message {typeof(TMessage).Name}, id: {messageId} was not accepted by a broker!)\");\n            };\n        }\n        \n        if (reliablePublishing.ShouldPublishAsMandatory<TMessage>())\n        {\n            channel.BasicReturnAsync += async (s, args) =>\n            {\n                Console.WriteLine($\"Message {typeof(TMessage).Name}, id: {messageId} was not routed properly to any consumer!)\");\n            };\n        }\n    }\n\n    private void SetPartitionKey<TMessage>(IBasicProperties basicProperties, TMessage? message)\n    {\n        if (FeatureFlags.UsePartitioningExample is false)\n        {\n            return;\n        }\n\n        if (typeof(IMessageWithPartitionKey).IsAssignableFrom(typeof(TMessage)))\n        {\n            var partitionKey = (message as IMessageWithPartitionKey)?.PartitionKey;\n            basicProperties.Headers.Add(RabbitMqTopologyBuilder.PartitionKeyHeaderName, partitionKey);\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Shared/TicketFlow.Shared/Messaging/RabbitMQ/RabbitMqMessagePublisher.cs b/src/Shared/TicketFlow.Shared/Messaging/RabbitMQ/RabbitMqMessagePublisher.cs
--- a/src/Shared/TicketFlow.Shared/Messaging/RabbitMQ/RabbitMqMessagePublisher.cs	(revision 644361c72a2d10368080dafc07296a68bdd2d53a)
+++ b/src/Shared/TicketFlow.Shared/Messaging/RabbitMQ/RabbitMqMessagePublisher.cs	(date 1754644788199)
@@ -31,8 +31,6 @@
             body: payload,
             mandatory: reliablePublishing.ShouldPublishAsMandatory<TMessage>(),
             cancellationToken: cancellationToken);
-        
-        
     }
 
     private BasicProperties CreateMessageProperties<TMessage>(string?  messageId = default, IDictionary<string, object>? headers = default)
